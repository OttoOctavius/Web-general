<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/gltf_validator.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script type='text/javascript' src='/torresinfinitas/pepe.js'></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");
        var actual;
        var createScene = function () {
            var scene = new BABYLON.Scene(engine);
            scene.collisionsEnabled = true;
            //main();
            // Setup a simple environment
            var light0 = new BABYLON.PointLight("Omni", new BABYLON.Vector3(0, 2, 8), scene);
            var box1 = BABYLON.Mesh.CreateBox("b1", 1.0, scene);
            var torus = BABYLON.Mesh.CreateTorus("torus", 3, 1, 32, scene);
            torus.position.x = -3;

            var blueMat = new BABYLON.StandardMaterial("ground1", scene);
                blueMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                blueMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                blueMat.emissiveColor = BABYLON.Color3.Blue();

            var redMat = new BABYLON.StandardMaterial("ground2", scene);
                    redMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                    redMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                    redMat.emissiveColor = BABYLON.Color3.Red();
            var greenMat = new BABYLON.StandardMaterial("ground2", scene);
                greenMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                greenMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
                greenMat.emissiveColor = BABYLON.Color3.Green();

            actual = torus.material;
            var box3 = BABYLON.Mesh.CreateBox("b3", 1.0, scene);
            box3.position.x = 3;

            torus.material = blueMat;
            box1.material = redMat;
            box3.material = greenMat;

            var freeCamera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 0, 5), scene);
                freeCamera.position = new BABYLON.Vector3(-tam*2,-tam/2,-tam);
                freeCamera.rotation = new BABYLON.Vector3(0, 0, 0);
                freeCamera.checkCollisions = true;
                freeCamera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
 
            scene.activeCamera = freeCamera;
            freeCamera.attachControl(canvas, true);
            
            //eventos(scene);
        //hacermovible(box1,scene);
            var renderTarget = shader(scene);
            
            var lista = salon(scene);
            //lista.forEach( e => renderTarget.renderList.push(e));
            
            pasilloancho(scene,renderTarget);

            return scene;
        }
        
        function shader(scene) {
            // depth material
            BABYLON.Effect.ShadersStore["depthVertexShader"] = 
                "#ifdef GL_ES\n" +
                "precision highp float;\n" +
                "#endif\n" +
                "attribute vec3 position;\n" +
                "uniform mat4 worldViewProjection;\n" +
                "void main(void) {\n" +
                "gl_Position = worldViewProjection * vec4(position, 1.0);\n" +
                "}";
            BABYLON.Effect.ShadersStore["depthPixelShader"] =
                "#ifdef GL_ES\n" +
                "precision highp float;\n" +
                "#endif\n" +
        
                "void main(void) {\n" +
                "gl_FragColor = vec4(0, 0, 0, 0.0);\n" +
                "}\n" +
                "";
        
            var depthMaterial = new BABYLON.ShaderMaterial("depth", scene, "depth",
                {
                    attributes: ["position"],
                    uniforms: ["worldViewProjection"],
        			needAlphaBlending: true
                });
        
            depthMaterial.backFaceCulling = true;

            // Render target
            var renderTarget = new BABYLON.RenderTargetTexture("depth", 1024, scene);
            scene.customRenderTargets.push(renderTarget);
        
            renderTarget.onBeforeRender = function () {
                for (var index = 0; index < renderTarget.renderList.length; index++) {
                    renderTarget.renderList[index]._savedMaterial = renderTarget.renderList[index].material;
                    renderTarget.renderList[index].material = depthMaterial;
                }
            }
        
            renderTarget.onAfterRender = function () {
                // Restoring previoux material
                for (var index = 0; index < renderTarget.renderList.length; index++) {
                    renderTarget.renderList[index].material = renderTarget.renderList[index]._savedMaterial;
        		}
            }
            return renderTarget;
        }

        function salon(scene) {
            var light = new BABYLON.PointLight("Omni0", new BABYLON.Vector3(50+tam*5, 50+tam*5, tam/2), scene);
            var lista = [];
            for (let x = 0; x <= 10 ; x++) {
                var pared = plano("Z " + x, scene);
                    pared.position.x =  50+tam*x;
                    pared.position.z = 50 - tam/2;
                    pared.rotation.z = Math.PI/2;
                    pared.rotation.y = Math.PI/2;
                    lista.push(pared);
                var pared = plano("Z10 " + x, scene);
                    pared.position.x =  50+tam*x;
                    pared.position.z = 50+tam*10+ tam/2;
                    pared.rotation.y = Math.PI/2;
                    pared.rotation.z = -Math.PI/2;
                    lista.push(pared);
                for (let z = 0; z <= 10 ; z++) {
                        var box = pisotecho(x+z ,scene); 
                        box.forEach( (pl)=> {pl.position.x = 50+tam*x;
                                             pl.position.z = 50+tam*z;} )
                        box.checkCollisions = true;
                        lista.push(box);
                }
                var pared = plano("X " + x, scene);
                    pared.position.x =  50 - tam/2;
                    pared.position.z = 50+tam*x;
                    pared.rotation.z = Math.PI/2;
                    pared.rotation.y = Math.PI;
                    lista.push(pared);
                var pared = plano("X10 " + x, scene);
                    pared.position.x = 50+tam*10+ tam/2;
                    pared.position.z =  50+tam*x;
                    pared.rotation.z = Math.PI/2;
                    //pared.rotation.y = Math.PI;
                    lista.push(pared);
            }
            return lista;
        }

        function eventos(scene,meshes){
            for (var i=0; i< meshes.length; i++) {
                let mesh = meshes[i];
                mesh.actionManager = new BABYLON.ActionManager(scene);
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnLongPressTrigger, (function(mesh) {
                    console.log("%c ActionManager: long press : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnLeftPickTrigger, (function(mesh) {
                    temp = actual;
                    actual = mesh.material;
                    mesh.material = temp;
                    console.log("%c ActionManager: left pick: " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnRightPickTrigger, (function(mesh) {
                    console.log("%c ActionManager: right pick: " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnCenterPickTrigger, (function(mesh) {
                    console.log("%c ActionManager: center pick: " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, (function(mesh) {
                    console.log("%c ActionManager: pick : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickDownTrigger, (function(mesh) {
                    console.log("%c ActionManager: pick down : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickUpTrigger, (function(mesh) {
                    console.log("%c ActionManager: pick up : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnDoublePickTrigger, (function(mesh) {
                    console.log("%c ActionManager: double pick : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
                mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickOutTrigger, (function(mesh) {
                    console.log("%c ActionManager: pick out : " + mesh.name, 'background: green; color: white');
                }).bind(this, mesh)));
            }
        }
        
        const tam = 15;

        var plano = function(name,scene) {
            var pl =  BABYLON.Mesh.CreateGround(name, tam, tam, 1, scene);
                pl.checkCollisions = true;
            return pl;
        }

        var pisotecho = function(i,scene){
            var piso = plano("piso"+i, scene);
                piso.position.y = -tam/2;
            var techo = plano("techo"+i,scene);
                techo.position.y = tam/2;
                techo.rotation.x = Math.PI;
            //eventos(scene,[piso,techo]);
            return [piso,techo];
        }
        var pasillo = function(i,scene){
            var piso = plano("piso"+i, scene);
                piso.position.y = -tam/2;
            var techo = plano("techo"+i,scene);
                techo.position.y = tam/2;
                techo.rotation.x = Math.PI;
            var paredi = plano("paredi"+i, scene);
                paredi.position.z = -tam/2;
                paredi.rotation.x = Math.PI/2;
            var paredd = plano("paredd"+i, scene);
                paredd.rotation.x = -Math.PI/2;
                paredd.position.z = tam/2;
            //eventos(scene,[piso,techo,paredi,paredd]);
            return [piso,techo,paredi,paredd];
        }
        var pasillo2 = function(i,scene){
            var piso = plano("piso"+i, scene);
                piso.position.y = -tam/2;
            var techo = plano("techo"+i, scene);
                techo.position.y = tam/2;
                techo.rotation.x = Math.PI;
            var paredi = plano("paredi"+i, scene);
                paredi.position.x = tam/2;
                paredi.rotation.z = Math.PI/2;
            var paredd = plano("paredd"+i,scene);
                paredd.position.x = -tam/2;
                paredd.rotation.z = -Math.PI/2;
            //eventos(scene,[piso,techo,paredi,paredd]);
            return [piso,techo,paredi,paredd];
        }
        function pasilloancho(scene,renderTarget) {
            // Render target
            var mat = new BABYLON.StandardMaterial("plan mat", scene);
                mat.diffuseColor = BABYLON.Color3.Black();
                mat.specularColor = BABYLON.Color3.Black();
                mat.emissiveTexture = renderTarget;
                mat.opacityTexture = renderTarget;
            var pared = plano("", scene);
                pared.position.x = tam/2;
                pared.rotation.z = Math.PI/2;
                pared.material = mat;
            pasillo(0,scene);
            pasillo(1,scene).map( (pl)=> pl.position.x += -tam*2)
            pasillo(2,scene).map( (pl)=> pl.position.x += -tam*1);
            pisotecho(4,scene).map( (pl)=> pl.position.x += -tam*3);
            var pared = plano("", scene);
                pared.position.x = -tam*4 + tam/2
                pared.rotation.z = -Math.PI/2;
            var pared = plano("", scene);
                pared.position.x = -tam*3;
                pared.position.z = tam/2;
                pared.rotation.y = -Math.PI;
                pared.rotation.x = Math.PI/2;
            pasillo2(4,scene).map( (pl)=> {pl.position.x += -tam*3;pl.position.z += -tam;});
        }
        var engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        var scene = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
